<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Land Research: Brides-les-Bains</title>

    <!-- MapLibre GL JS -->
    <link href="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.css" rel="stylesheet" />
    <script src="https://unpkg.com/maplibre-gl@4.7.1/dist/maplibre-gl.js"></script>

    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>

    <!-- Turf.js for Geospatial Analysis -->
    <script src="https://unpkg.com/@turf/turf/turf.min.js"></script>

    <!-- Driver.js for Tour -->
    <script src="https://cdn.jsdelivr.net/npm/driver.js@1.0.1/dist/driver.js.iife.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/driver.js@1.0.1/dist/driver.css" />

    <style>
        body {
            margin: 0;
            padding: 0;
            font-family: 'Inter', sans-serif;
            overflow: hidden;
            background-color: #0f172a;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }

        /* Driver JS customization */
        .driver-popover.driverjs-theme {
            background-color: #1e293b;
            color: white;
            border: 1px solid #334155;
        }

        .driver-popover-title {
            font-weight: bold;
            font-size: 16px;
        }

        .driver-popover-description {
            font-size: 14px;
            color: #cbd5e1;
        }

        .driver-popover-close-btn {
            color: #94a3b8;
        }

        /* Progress Bar */
        .progress-bar {
            width: 0%;
            transition: width 0.5s ease;
        }

        /* Breathing Animation */
        @keyframes breathing {
            0% {
                transform: scale(1);
                opacity: 0.8;
                box-shadow: 0 0 0 0 rgba(168, 85, 247, 0.7);
            }

            50% {
                transform: scale(1.1);
                opacity: 1;
                box-shadow: 0 0 20px 10px rgba(168, 85, 247, 0);
            }

            100% {
                transform: scale(1);
                opacity: 0.8;
                box-shadow: 0 0 0 0 rgba(168, 85, 247, 0.7);
            }
        }

        .animate-breathe {
            animation: breathing 2s infinite ease-in-out;
        }
    </style>
</head>

<body class="bg-gray-900 text-white overflow-hidden font-sans">

    <!-- Map Container -->
    <div id="map"></div>

    <!-- UI Overlay: Sidebar -->
    <div id="sidebar" class="absolute top-4 left-4 w-80 z-20 flex flex-col gap-4 pointer-events-none"
        style="max-height: calc(100vh - 2rem);">

        <!-- CONTROL BUTTONS TOP -->
        <div class="flex flex-col gap-2 pointer-events-auto shrink-0">
            <div class="flex gap-2">
                <button onclick="document.getElementById('welcomeModal').classList.remove('hidden')"
                    class="bg-gray-800/80 hover:bg-gray-700 text-white p-2 rounded-lg backdrop-blur-sm border border-white/10 text-xs flex items-center gap-1">
                    <span>üëã</span> Help
                </button>
                <div
                    class="px-2 py-1 bg-purple-900/50 text-purple-200 text-[10px] rounded border border-purple-500/30 flex items-center">
                    v2.0 Multi-Commune
                </div>
            </div>

            <!-- COMMUNE FILTER -->
            <select id="communeFilter" onchange="filterMapByCommune(this.value)"
                class="w-full bg-gray-900/90 text-white text-xs rounded-lg border border-white/20 p-2 focus:outline-none focus:border-blue-500 backdrop-blur-sm shadow-lg">
                <option value="all">üåç All Communes (Limit View)</option>
                <option value="73057">üèòÔ∏è Brides-les-Bains</option>
                <option value="73284">üèòÔ∏è Salins-les-Thermes (Merged)</option>
                <option value="73055">üèòÔ∏è Bozel</option>
                <option value="73227">üèòÔ∏è Courchevel (Le Praz)</option>
            </select>
        </div>

        <!-- Main Panel -->
        <div id="parcelInfoPanel"
            class="bg-gray-900/90 backdrop-blur-md rounded-2xl shadow-2xl border border-white/10 overflow-hidden pointer-events-auto flex flex-col min-h-0">
            <!-- Header -->
            <div class="p-6 border-b border-white/10 shrink-0">
                <h1
                    class="text-2xl font-bold bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-400">
                    Land Research
                </h1>
                <p id="appSubtitle" class="text-xs text-gray-400 mt-1 uppercase tracking-widest">All Communes</p>
            </div>

            <!-- Stats / Filters -->
            <div class="p-6 space-y-6 overflow-y-auto flex-1">

                <!-- Stats Row -->
                <!-- ADDRESS SEARCH -->
                <div class="relative mb-4">
                    <div
                        class="flex items-center bg-gray-800 rounded-lg border border-white/20 p-2 gap-2 focus-within:border-blue-500 focus-within:ring-1 focus-within:ring-blue-500">
                        <span class="text-gray-400">üîç</span>
                        <input type="text" id="addressSearch" placeholder="Search Address..."
                            class="bg-transparent border-none text-white text-xs w-full focus:outline-none"
                            oninput="handleAddressSearch(this.value)">
                        <button onclick="clearAddressSearch()" id="clearAddrBtn"
                            class="hidden text-gray-500 hover:text-white">‚úï</button>
                    </div>
                    <!-- Results Dropdown -->
                    <div id="addrResults"
                        class="hidden absolute top-full left-0 right-0 mt-1 bg-gray-800 border border-white/20 rounded-lg shadow-xl z-50 max-h-48 overflow-y-auto">
                        <!-- Items injected here -->
                    </div>
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <div class="bg-gray-800/50 p-4 rounded-xl text-center">
                        <div class="text-2xl font-bold text-blue-400" id="totalParcelCount">-</div>
                        <div class="text-xs text-gray-500 uppercase">Parcels</div>
                    </div>
                    <div class="bg-gray-800/50 p-4 rounded-xl text-center">
                        <div class="text-2xl font-bold text-purple-400" id="avgSize">0</div>
                        <div class="text-xs text-gray-500 uppercase">Avg Size (m¬≤)</div>
                    </div>
                </div>

                <!-- Filters -->
                <div class="space-y-4">
                    <div class="flex justify-between items-center">
                        <label class="text-sm font-medium text-gray-300">Min Size (m¬≤)</label>
                        <span class="text-xs text-blue-400 font-mono" id="sizeVal">0</span>
                    </div>
                    <input type="range" id="sizeFilter" min="0" max="10000" value="0" step="100"
                        class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer accent-blue-500">
                </div>

                <!-- PERSISTENT TOOLS (Moved out of hidden parcelInfo) -->
                <div id="persistentTools" class="space-y-3 pt-4 border-t border-white/10">

                    <!-- RECOMMENDATION BUTTON -->
                    <button onclick="openRecModal()" id="recModalBtn"
                        class="w-full py-3 bg-gradient-to-r from-emerald-600 to-teal-600 hover:from-emerald-500 hover:to-teal-500 rounded-lg text-sm font-bold text-white shadow-lg transition-all flex items-center justify-center gap-2 group">
                        <span>üéØ Find Best Land</span>
                    </button>

                    <!-- PORTFOLIO SECTION -->
                    <div id="portfolioSection" class="bg-gray-800/30 rounded-xl p-3 border border-white/5">
                        <h3 class="text-xs font-bold text-gray-300 mb-2 flex justify-between items-center">
                            <span>üìÇ My Portfolio</span>
                            <span id="pfCount"
                                class="text-[10px] bg-blue-600 px-2 py-0.5 rounded-full text-white">0</span>
                        </h3>

                        <div id="pfList" class="space-y-1 max-h-32 overflow-y-auto mb-2 pr-1 custom-scrollbar">
                            <!-- Items Injected Here -->
                            <div class="text-xs text-gray-500 italic">No saved plots yet.</div>
                        </div>

                        <div class="flex gap-2">
                            <button
                                class="flex-1 py-1.5 bg-pink-600/80 hover:bg-pink-500 rounded text-xs font-semibold transition-colors flex items-center justify-center gap-1"
                                onclick="highlightPortfolio()">
                                <span>üìç Show All</span>
                            </button>
                            <button onclick="document.getElementById('uploadDocModal').classList.remove('hidden')"
                                class="flex-1 py-1.5 bg-gray-700 hover:bg-gray-600 border border-white/10 rounded text-xs font-semibold transition-colors flex items-center justify-center gap-1 text-gray-300">
                                <span>üìÑ Upload Doc</span>
                            </button>
                        </div>
                    </div>
                </div>



                <!-- Selected Parcel Info -->
                <div id="parcelInfo" class="hidden animate-fade-in pt-4 border-t border-white/10">
                    <h3 class="text-lg font-semibold text-white mb-3">Selected Plot</h3>
                    <div class="space-y-3 text-sm">
                        <div class="flex justify-between">
                            <span class="text-gray-400">ID</span>
                            <span class="font-mono text-white" id="pId">--</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Area</span>
                            <span class="font-mono text-white" id="pArea">-- m¬≤</span>
                        </div>
                        <div class="flex flex-col gap-1">
                            <span class="text-gray-400 text-xs uppercase tracking-wider">Buildable Status</span>
                            <div class="font-mono text-sm break-words" id="pBuild">--</div>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Est. Slope</span>
                            <span class="font-mono text-green-400" id="pSlope">--</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-gray-400">Owner</span>
                            <span class="font-mono text-blue-400" id="pOwner">--</span>
                        </div>
                        <div class="pt-2 border-t border-white/5 space-y-2" id="pEnrichment">
                            <!-- Injected by JS -->
                        </div>
                    </div>

                    <!-- Agent Button -->
                    <button id="btnAgent"
                        class="mt-4 w-full py-3 bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-500 hover:to-indigo-500 rounded-lg text-sm font-bold text-white shadow-lg transition-all flex items-center justify-center gap-2 group">
                        <span>‚ú® Ask Agent to Analyze</span>
                    </button>

                    <!-- Copy Info Button (Hidden by default) -->
                    <button id="btnCopyRequest"
                        class="hidden mt-2 w-full py-2 bg-gray-700 hover:bg-gray-600 rounded text-xs text-gray-300 border border-gray-600 flex items-center justify-center gap-2">
                        üìã Copy Official Request Letter
                    </button>

                    <button
                        class="mt-4 w-full py-2 bg-blue-600 hover:bg-blue-500 rounded-lg text-sm font-semibold transition-colors"
                        onclick="resetSelection()">
                        Clear Selection
                    </button>
                </div>

                <div id="emptyState" class="text-center py-10 text-gray-500 text-sm">
                    Hover or click a parcel to view details.
                </div>

            </div>

            <!-- Footer -->
            <div class="p-4 bg-black/20 text-xs text-center text-gray-600">
                Data sources: Cadastre Etalab, IGN
            </div>
        </div>
    </div>

    <!-- Loading Indicator -->
    <!-- Loading Indicator -->
    <div id="loader"
        class="absolute inset-0 z-50 bg-gray-900 flex flex-col items-center justify-center transition-opacity duration-500">
        <div class="w-64 h-2 bg-gray-800 rounded-full overflow-hidden mb-4 relative">
            <div id="progressBar" class="h-full bg-gradient-to-r from-purple-500 to-blue-500 progress-bar"></div>
        </div>
        <p class="text-gray-400 text-sm tracking-wider font-mono" id="loaderText">Initializing App...</p>
        <div id="errorLog"
            class="hidden mt-4 p-4 bg-red-900/50 text-red-200 text-xs font-mono rounded max-w-lg text-left whitespace-pre-wrap">
        </div>
    </div>

    <script>
        // Global Error Handler
        window.onerror = function (msg, url, line, col, error) {
            const log = document.getElementById('errorLog');
            if (log) {
                log.classList.remove('hidden');
                log.innerText += `Error: ${msg}\nLine: ${line}\n\n`;
            }
            // Update loader text to show failure
            const txt = document.getElementById('loaderText');
            if (txt) txt.innerText = "App Crash (See Log)";
        };
    </script>

    <!-- WELCOME MODAL -->
    <div id="welcomeModal"
        class="hidden absolute inset-0 z-[70] bg-black/90 backdrop-blur-md flex items-center justify-center p-4">
        <div
            class="bg-gray-900 border border-purple-500/30 rounded-2xl w-full max-w-2xl p-8 shadow-2xl relative text-center">
            <button onclick="closeWelcomeModal()"
                class="absolute top-4 right-4 text-gray-500 hover:text-white">‚úï</button>
            <div
                class="w-16 h-16 bg-gradient-to-br from-purple-600 to-indigo-600 rounded-2xl mx-auto flex items-center justify-center mb-6 shadow-lg shadow-purple-500/20">
                <span class="text-3xl">üèîÔ∏è</span>
            </div>

            <h1 class="text-3xl font-bold text-white mb-2">Welcome to Land Agent AI</h1>
            <p class="text-gray-400 mb-8 max-w-lg mx-auto">Your intelligent assistant for discovering buildable land in
                the French Alps. Analyze slopes, estimate prices, and find hidden gems.</p>

            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-8 text-left">
                <div class="bg-gray-800/50 p-4 rounded-xl border border-white/5">
                    <div class="text-purple-400 font-bold mb-1">üîç Smart Analysis</div>
                    <div class="text-xs text-gray-400">Instant evaluation of buildable area, slope, and elevation for
                        any parcel.</div>
                </div>
                <div class="bg-gray-800/50 p-4 rounded-xl border border-white/5">
                    <div class="text-emerald-400 font-bold mb-1">üí∞ Price Estimation</div>
                    <div class="text-xs text-gray-400">Live market data from DVF government records to estimate fair
                        value.</div>
                </div>
                <div class="bg-gray-800/50 p-4 rounded-xl border border-white/5">
                    <div class="text-blue-400 font-bold mb-1">üéØ Recommendations</div>
                    <div class="text-xs text-gray-400">Tell us what you want, and the Agent will proactively find the
                        best matches.</div>
                </div>
            </div>

            <div class="flex gap-4 justify-center">
                <button onclick="startTour()"
                    class="px-6 py-3 bg-gradient-to-r from-purple-600 to-indigo-600 hover:from-purple-500 hover:to-indigo-500 rounded-lg font-bold text-white shadow-lg transition-transform hover:scale-105">
                    üöÄ Start Live Tour
                </button>
                <button onclick="closeWelcomeModal()"
                    class="px-6 py-3 bg-gray-800 hover:bg-gray-700 border border-gray-700 rounded-lg font-semibold text-gray-300">
                    Skip
                </button>
            </div>
        </div>
    </div>

    <!-- RECOMMENDATION MODAL -->
    <div id="recModal"
        class="hidden absolute inset-0 z-[60] bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
        <div class="bg-gray-900 border border-white/10 rounded-2xl w-full max-w-md p-6 shadow-2xl relative">
            <button onclick="closeRecModal()" class="absolute top-4 right-4 text-gray-400 hover:text-white">‚úï</button>

            <h2 class="text-xl font-bold text-white mb-1">Find Best Land</h2>
            <p class="text-xs text-gray-400 mb-6">Enter your project specs to find recommendations.</p>

            <div class="space-y-4">
                <!-- Project Type Removed -->

                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label class="block text-xs text-gray-400 mb-1">Min Area (m¬≤)</label>
                        <input type="number" id="recMinArea" value="500"
                            class="w-full bg-gray-800 border border-gray-700 rounded p-2 text-white text-sm">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-400 mb-1">Max Area (m¬≤)</label>
                        <input type="number" id="recMaxArea" placeholder="Unlimited"
                            class="w-full bg-gray-800 border border-gray-700 rounded p-2 text-white text-sm">
                    </div>
                    <div>
                        <label class="block text-xs text-gray-400 mb-1">Max Slope (%)</label>
                        <input type="number" id="recMaxSlope" value="30"
                            class="w-full bg-gray-800 border border-gray-700 rounded p-2 text-white text-sm">
                    </div>
                    <div class="col-span-2">
                        <label class="block text-xs text-gray-400 mb-1">Est. Buildable % (Default)</label>
                        <input type="number" id="recEstPercent" value="80"
                            class="w-full bg-gray-800 border border-gray-700 rounded p-2 text-white text-sm">
                    </div>
                </div>

                <!-- Scope Selector -->
                <div class="mt-4">
                    <label class="block text-xs text-gray-400 mb-1">Search Area</label>
                    <select id="recScopeSelect" onchange="findBestLands(true)"
                        class="w-full bg-gray-800 border border-gray-700 rounded p-2 text-white text-sm focus:border-blue-500 outline-none">
                        <option value="all">üåç All Communes</option>
                        <option value="73057">Brides-les-Bains</option>
                        <option value="73284">Salins-les-Thermes</option>
                        <option value="73055">Bozel</option>
                        <option value="73227">Courchevel (Le Praz)</option>
                    </select>
                </div>
            </div>

            <button onclick="findBestLands()"
                class="w-full py-3 bg-gradient-to-r from-emerald-600 to-teal-600 hover:from-emerald-500 hover:to-teal-500 rounded-lg text-sm font-bold text-white shadow-lg mt-4">
                üîç Find Top Matches
            </button>
            <div id="recStatus" class="text-xs text-center text-blue-400 h-4 mt-1 font-mono animate-pulse"></div>

            <!-- RESULTS LIST -->
            <div id="recResults"
                class="mt-6 space-y-2 max-h-60 overflow-y-auto border border-white/20 min-h-[50px] p-2 bg-black/40">
                <div class="text-gray-500 text-xs text-center">Results will appear here...</div>
            </div>
        </div>
    </div>

    <!-- UPLOAD DOC MODAL -->
    <div id="uploadDocModal"
        class="hidden absolute inset-0 z-[80] bg-black/80 backdrop-blur-sm flex items-center justify-center p-4">
        <div class="bg-gray-900 border border-white/10 rounded-2xl w-full max-w-md p-6 shadow-2xl relative">
            <button onclick="document.getElementById('uploadDocModal').classList.add('hidden')"
                class="absolute top-4 right-4 text-gray-400 hover:text-white">‚úï</button>

            <h2 class="text-xl font-bold text-white mb-4">Upload Document</h2>
            <p class="text-xs text-gray-400 mb-6">Upload a PDF or Image (Plan, Deed) to view it alongside the map. We'll
                try to auto-detect plot numbers from PDFs.</p>

            <input type="file" id="docFile" accept=".pdf,.png,.jpg,.jpeg"
                class="w-full text-sm text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-xs file:font-semibold file:bg-blue-600 file:text-white hover:file:bg-blue-500" />

            <div class="mt-4">
                <label class="block text-xs text-gray-400 mb-1">Gemini API Key (Optional)</label>
                <input type="password" id="geminiKey" placeholder="Paste your API Key here to use your own quota"
                    class="w-full bg-gray-800 border border-gray-700 rounded p-2 text-white text-xs focus:border-blue-500 outline-none"
                    oninput="checkKeyWarning()">
                <div class="text-[10px] text-gray-500 mt-1">Key is saved locally in your browser.</div>

                <div id="apiWarning"
                    class="hidden mt-2 p-2 bg-yellow-900/50 border border-yellow-700/50 rounded text-xs text-yellow-200">
                    ‚ö†Ô∏è <b>No API Key!</b> Smart detection will be disabled. Only the document viewer will be available.
                </div>
            </div>

            <button onclick="uploadDocument()" id="btnUpload"
                class="mt-6 w-full py-3 bg-gradient-to-r from-blue-600 to-cyan-600 hover:from-blue-500 hover:to-cyan-500 rounded-lg text-sm font-bold text-white shadow-lg">
                üöÄ Upload & Analyze
            </button>
        </div>
    </div>

    <!-- DOC VIEWER (Floating) -->
    <div id="docViewer"
        class="hidden absolute right-4 top-20 w-[400px] h-[600px] bg-gray-900/95 border border-white/20 rounded-xl shadow-2xl z-30 flex flex-col resize overflow-hidden">
        <div class="p-3 border-b border-white/10 flex justify-between items-center bg-gray-800 cursor-move"
            id="docHeader">
            <span class="text-sm font-bold text-white">üìÑ Document Viewer</span>
            <div class="flex gap-2">
                <button onclick="toggleDocOpacity()" class="text-xs text-gray-400 hover:text-white"
                    title="Toggle Transparency">üëÅÔ∏è</button>
                <button onclick="closeDocViewer()" class="text-xs text-gray-400 hover:text-white">‚úï</button>
            </div>
        </div>

        <div id="docSuggestions"
            class="hidden p-2 bg-blue-900/20 border-b border-white/10 shrink-0 flex flex-col gap-2">
            <!-- Auto Suggestions -->
            <div id="autoSuggContainer" class="block">
                <div class="text-[10px] text-blue-300 uppercase font-bold mb-1">Detected Plots:</div>
                <div id="docIdsList" class="flex flex-wrap gap-1 max-h-20 overflow-y-auto"></div>
            </div>
        </div>

        <div class="flex-1 overflow-auto bg-white/5 relative p-2 flex items-center justify-center">
            <iframe id="pdfFrame" class="hidden w-full h-full border-0"></iframe>
            <img id="imgFrame" class="hidden max-w-full max-h-full object-contain" />
        </div>
    </div>

    <script>
        // Init Map
        const map = new maplibregl.Map({
            container: 'map',
            style: {
                version: 8,
                sources: {
                    'satellite': {
                        type: 'raster',
                        tiles: [
                            'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}'
                        ],
                        tileSize: 256,
                        attribution: '&copy; Esri'
                    }
                },
                layers: [
                    {
                        id: 'satellite-layer',
                        type: 'raster',
                        source: 'satellite',
                        paint: {}
                    }
                ]
            },
            center: [6.57, 45.45], // Brides-les-Bains approx
            zoom: 14,
            pitch: 45,
            bearing: -20,
            antialias: true
        });

        map.addControl(new maplibregl.NavigationControl({ visualVisualizePitch: true }), 'top-right');

        // RE-ADD LOAD LISTENER (Was accidentally deleted)
        map.on('load', () => {
            loadData();
        });

        let parcelsData = null;
        let analysisQueue = [];
        let isAnalyzing = false;

        // --- GLOBAL STATE ---
        const APP_STATE = {
            commune: 'all',
            minSize: 0
        };

        const HUBS = {
            '73057': { name: 'Olympe Lift', coords: [6.566, 45.451] }, // Brides
            '73284': { name: 'Olympe Lift', coords: [6.566, 45.451] }, // Salins (Merged)
            '73055': { name: 'Bozel Center', coords: [6.6488, 45.4522] }, // Bozel
            '73227': { name: 'Le Praz Lift', coords: [6.628, 45.432] }  // Courchevel Le Praz
        };

        function getHub(id) {
            const prefix = id.substring(0, 5);
            return HUBS[prefix] || HUBS['73057']; // Default to Brides
        }

        // Haversine Distance (m)
        function calcDistance(c1, c2) {
            const R = 6371e3; // Earth radius in metres
            const œÜ1 = c1[1] * Math.PI / 180;
            const œÜ2 = c2[1] * Math.PI / 180;
            const ŒîœÜ = (c2[1] - c1[1]) * Math.PI / 180;
            const ŒîŒª = (c2[0] - c1[0]) * Math.PI / 180;
            const a = Math.sin(ŒîœÜ / 2) * Math.sin(ŒîœÜ / 2) +
                Math.cos(œÜ1) * Math.cos(œÜ2) *
                Math.sin(ŒîŒª / 2) * Math.sin(ŒîŒª / 2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
            return Math.round(R * c);
        }

        function enrichFeature(f) {
            const p = f.properties;
            // 1. Polyfill Area
            if (!p.total_area_sqm) p.total_area_sqm = p.contenance || 0;

            // 2. Calculate Distance if missing
            if (!p.dist_to_hub) {
                const hub = getHub(p.id);
                // Centroid helper (simple average of bbox if turf unavailable, but we have turf)
                if (window.turf) {
                    const center = turf.center(f);
                    p.dist_to_hub = calcDistance(center.geometry.coordinates, hub.coords);
                }
            }
        }

        function loadData() {
            const loaderText = document.getElementById('loaderText');
            const pBar = document.getElementById('progressBar');

            if (pBar) pBar.style.width = "10%";
            if (loaderText) loaderText.innerHTML = "üì° Downloading Map Data...";

            // Fetch GeoJSON
            fetch('/api/parcels')
                .then(response => {
                    if (!response.ok) throw new Error("Failed to load data");

                    if (pBar) pBar.style.width = "40%";
                    if (loaderText) loaderText.innerHTML = "‚öôÔ∏è Parsing Data...";
                    return response.json();
                })
                .then(data => {
                    if (pBar) pBar.style.width = "70%";
                    if (loaderText) loaderText.innerHTML = "üé® Rendering Map...";

                    // Pre-process (Polyfill)
                    const len = data.features.length;
                    for (let i = 0; i < len; i++) {
                        enrichFeature(data.features[i]);
                    }

                    parcelsData = data;
                    if (map.getSource('parcels')) {
                        map.getSource('parcels').setData(data);
                        updateStats(data.features);
                    } else {
                        initData(data);
                    }

                    if (pBar) pBar.style.width = "100%";
                })
                .catch(err => {
                    console.error("Error loading data:", err);
                    if (loaderText) loaderText.innerHTML = "<span class='text-red-500'>Failed: " + err.message + "</span>";
                });
        }

        function applyFilters() {
            // Combine Commune + Min Size
            const filters = ['all'];

            // 1. Commune
            if (APP_STATE.commune !== 'all' && APP_STATE.commune !== 'debug') {
                filters.push(['==', ['slice', ['get', 'id'], 0, 5], APP_STATE.commune]);
            }

            // 2. Size
            if (APP_STATE.minSize > 0) {
                filters.push(['>=', 'total_area_sqm', APP_STATE.minSize]);
            }

            // Apply
            const finalFilter = filters.length > 1 ? filters : null;
            if (map.getLayer('parcels-fill')) {
                map.setFilter('parcels-fill', finalFilter);
                map.setFilter('parcels-line', finalFilter);
            }

            // Update Stats based on Memory Filter (for Sidebar numbers)
            if (parcelsData) {
                const visible = parcelsData.features.filter(f => {
                    const matchCommune = (APP_STATE.commune === 'all' || APP_STATE.commune === 'debug') ? true : f.properties.id.startsWith(APP_STATE.commune);
                    const matchSize = f.properties.total_area_sqm >= APP_STATE.minSize;
                    return matchCommune && matchSize;
                });
                updateStats(visible);
            }
        }

        function updateStats(features) {
            document.getElementById('totalParcelCount').innerText = features.length;
            if (features.length > 0) {
                const totalArea = features.reduce((acc, f) => acc + (f.properties.total_area_sqm || 0), 0);
                const avg = totalArea / features.length;
                document.getElementById('avgSize').innerText = Math.round(avg);
            } else {
                document.getElementById('avgSize').innerText = "0";
            }
        }

        function initData(data) {
            updateStats(data.features);

            // Add Source
            map.addSource('parcels', {
                type: 'geojson',
                data: data
            });

            // Add Fill Layer
            map.addLayer({
                'id': 'parcels-fill',
                'type': 'fill',
                'source': 'parcels',
                'paint': {
                    'fill-color': [
                        'interpolate',
                        ['linear'],
                        ['get', 'total_area_sqm'],
                        0, '#3b82f6',    // Blue for small
                        1000, '#8b5cf6', // Purple
                        5000, '#ec4899'  // Pink for huge
                    ],
                    'fill-opacity': 0.4,
                    'fill-outline-color': 'rgba(255,255,255,0.5)'
                }
            });

            // Add Line Layer (Outlines for sharpness)
            map.addLayer({
                'id': 'parcels-line',
                'type': 'line',
                'source': 'parcels',
                'paint': {
                    'line-color': '#fff',
                    'line-width': 1,
                    'line-opacity': 0.3
                }
            });

            // Highlight Layer
            map.addLayer({
                'id': 'parcels-highlight',
                'type': 'line',
                'source': 'parcels',
                'filter': ['==', 'id', ''],
                'paint': {
                    'line-color': '#fde047',
                    'line-width': 3
                }
            });

            // Fit bounds
            // Simple bound calculation since maplibre needs explicit LngLatBounds
            const coords = data.features[0].geometry.coordinates[0][0]; // naive start
            map.jumpTo({ center: coords, zoom: 15 });

            // Hide loader
            setTimeout(() => {
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').style.display = 'none', 500);
            }, 1000);

            setupInteractions();
        }

        function setupInteractions() {
            // Hover cursor
            map.on('mouseenter', 'parcels-fill', () => {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', 'parcels-fill', () => {
                map.getCanvas().style.cursor = '';
            });

            // Click
            map.on('click', 'parcels-fill', (e) => {
                const feature = e.features[0];
                selectParcel(feature);
            });

            // Filter Logic
            document.getElementById('sizeFilter').addEventListener('input', (e) => {
                const val = parseInt(e.target.value);
                document.getElementById('sizeVal').innerText = val + "+";
                APP_STATE.minSize = val;
                applyFilters();
            });

            // Recommendation Live Updates
            document.getElementById('recMinArea').addEventListener('input', () => findBestLands(true));
            document.getElementById('recMaxArea').addEventListener('input', () => findBestLands(true));
            document.getElementById('recMaxSlope').addEventListener('input', () => findBestLands(true));
            if (document.getElementById('recScopeSelect')) document.getElementById('recScopeSelect').addEventListener('change', () => findBestLands(true));
            document.getElementById('recEstPercent').addEventListener('input', () => { });
        }

        // --- ADDRESS SEARCH ---
        function handleAddressSearch(query) {
            const container = document.getElementById('addrResults');
            const clearBtn = document.getElementById('clearAddrBtn');
            const cleanQ = query.toLowerCase().trim();

            if (cleanQ.length === 0) {
                container.classList.add('hidden');
                clearBtn.classList.add('hidden');
                return;
            }
            clearBtn.classList.remove('hidden');

            if (!parcelsData) return;

            // Simple Filter
            const matches = parcelsData.features.filter(f => {
                const addr = f.properties.address;
                return addr && addr.toLowerCase().includes(cleanQ);
            }).slice(0, 10); // Top 10

            container.innerHTML = "";
            if (matches.length > 0) {
                container.classList.remove('hidden');
                matches.forEach(f => {
                    const div = document.createElement('div');
                    div.className = "px-3 py-2 hover:bg-gray-700 cursor-pointer text-xs text-white border-b border-white/5 last:border-0";
                    div.innerHTML = `
                        <div class="font-bold">${f.properties.address}</div>
                        <div class="text-[10px] text-gray-500">ID: ${f.properties.id}</div>
                    `;
                    div.onclick = () => {
                        selectParcel(f);
                        // Fly to
                        if (window.turf) {
                            const bbox = turf.bbox(f);
                            map.fitBounds(bbox, { padding: 100, maxZoom: 19 });
                        }
                        // Clear Search
                        container.classList.add('hidden');
                        document.getElementById('addressSearch').value = f.properties.address;
                    };
                    container.appendChild(div);
                });
            } else {
                container.innerHTML = "<div class='px-3 py-2 text-xs text-gray-500 italic'>No matches found</div>";
                container.classList.remove('hidden');
            }
        }

        function clearAddressSearch() {
            document.getElementById('addressSearch').value = "";
            document.getElementById('addrResults').classList.add('hidden');
            document.getElementById('clearAddrBtn').classList.add('hidden');
        }


        function selectParcel(feature) {
            clearCopyBtn();
            const props = feature.properties;

            // --- AUTO-RESET FILTERS (Make sure it has color!) ---
            let filtersChanged = false;

            // 1. Check Size
            if (APP_STATE.minSize > 0 && props.total_area_sqm < APP_STATE.minSize) {
                APP_STATE.minSize = 0;
                document.getElementById('sizeFilter').value = 0;
                document.getElementById('sizeVal').innerText = "0+";
                filtersChanged = true;
            }

            // 2. Check Commune & Switch Context
            const targetCommune = props.id.substring(0, 5);
            // If we are in 'all' mode, OR in a different commune, switch to the target
            if (APP_STATE.commune !== targetCommune && APP_STATE.commune !== 'debug') {
                APP_STATE.commune = targetCommune;
                document.getElementById('communeFilter').value = targetCommune;
                filtersChanged = true;
            }

            if (filtersChanged) {
                applyFilters(); // This re-shows the layer with color
            }
            // ----------------------------------------------------

            // Highlight map
            map.setFilter('parcels-highlight', ['==', 'id', props.id]);

            // Update UI
            document.getElementById('emptyState').classList.add('hidden');
            document.getElementById('parcelInfo').classList.remove('hidden');

            // --- UPDATE TITLE & SEARCH BAR ---
            // 1. Update Title based on Commune Code
            const code = props.id.substring(0, 5);
            let cName = "Unknown Commune";
            if (code === '73057') cName = "Brides-les-Bains";
            else if (code === '73284') cName = "Salins-les-Thermes";
            else if (code === '73055') cName = "Bozel";
            else if (code === '73227') cName = "Courchevel (Le Praz)";

            const sub = document.getElementById('appSubtitle');
            if (sub) sub.innerText = cName;

            // 2. Update Search Bar with Address
            const searchInput = document.getElementById('addressSearch');
            // Show clear button since we have text
            const clearBtn = document.getElementById('clearAddrBtn');

            if (searchInput) {
                searchInput.value = props.address || "";
                if (props.address && clearBtn) clearBtn.classList.remove('hidden');
            }
            // -------------------------------

            document.getElementById('pId').innerText = props.id;
            document.getElementById('pArea').innerText = Math.round(props.total_area_sqm) + " m¬≤";

            // Handle missing data gracefully
            let slope = "N/A";
            if (props.slope_mean != null) {
                const pct = Math.round(props.slope_mean);
                const deg = Math.round(Math.atan(props.slope_mean / 100) * (180 / Math.PI));
                slope = `${pct}% (${deg}¬∞)`;
            }
            const build = props.buildable_area_sqm ? Math.round(props.buildable_area_sqm) + " m¬≤" : "Unknown";
            const owner = props.owner_name ? props.owner_name : "Private (Upload CSV)";

            document.getElementById('pSlope').innerText = slope;
            document.getElementById('pBuild').innerText = build;
            document.getElementById('pOwner').innerText = owner;

            // Handle Enrichment Data
            const encDiv = document.getElementById('pEnrichment');
            encDiv.innerHTML = "";

            if (props.address) {
                encDiv.innerHTML += `
                    <div class="flex flex-col">
                        <span class="text-gray-400 text-xs uppercase">üìç Address</span>
                        <span class="text-white text-sm">${props.address}</span>
                    </div>`;
            }
            if (props.dist_to_hub) {
                const hub = getHub(props.id);
                encDiv.innerHTML += `
                    <div class="flex flex-col">
                        <span class="text-gray-400 text-xs uppercase">üö° Distance to Hub</span>
                        <span class="text-white text-sm">${props.dist_to_hub}m to ${hub.name}</span>
                    </div>`;
            }
            if (props.est_price_m2) {
                const total = Math.round((props.est_price_m2 * props.total_area_sqm) / 1000);
                encDiv.innerHTML += `
                    <div class="flex flex-col">
                        <span class="text-gray-400 text-xs uppercase">üí∞ Est. Market Price</span>
                        <span class="text-green-400 text-sm font-bold">‚Ç¨${props.est_price_m2}/m¬≤ (~‚Ç¨${total}k)</span>
                        <span class="text-[10px] text-gray-500">Based on DVF sales < 1km</span>
                    </div>`;
            }
            // setup Agent Button
            const btn = document.getElementById('btnAgent');
            btn.onclick = () => askAgent(props.id);

            // Setup Portfolio Button in Panel
            const pfContainer = document.getElementById('pEnrichment');
            // Append to enrichment area or create new slot? 
            // Let's add a specific action bar below the Agent button.
            // Actually, let's inject a Star button right inside the panel header or near Agent button.

            // We'll stick distinct buttons for clarity.
            // Check if already in portfolio
            const saved = PORTFOLIO_DATA && PORTFOLIO_DATA.saved_parcels && PORTFOLIO_DATA.saved_parcels[props.id];

            let pfHtml = "";
            if (saved) {
                // Show Status Dropdown
                pfHtml = `
                    <div class="mt-4 p-3 bg-blue-900/30 border border-blue-500/30 rounded-lg">
                        <div class="flex justify-between items-center mb-2">
                            <span class="text-xs text-blue-300 font-bold">‚ú® Saved in Portfolio</span>
                            <button onclick="removeFromPortfolio('${props.id}')" class="text-[10px] text-red-400 hover:underline">Remove</button>
                        </div>
                        <select onchange="updateStatus('${props.id}', this.value)" class="w-full bg-gray-900 border border-blue-500/50 text-xs text-white rounded p-1">
                            <option value="starred" ${saved.status === 'starred' ? 'selected' : ''}>‚≠ê Starred</option>
                            <option value="owner_requested" ${saved.status === 'owner_requested' ? 'selected' : ''}>üì´ Owner Requested</option>
                            <option value="owner_contacted" ${saved.status === 'owner_contacted' ? 'selected' : ''}>üó£Ô∏è Owner Contacted</option>
                            <option value="negotiating" ${saved.status === 'negotiating' ? 'selected' : ''}>ü§ù Negotiating</option>
                            <option value="acquired" ${saved.status === 'acquired' ? 'selected' : ''}>‚úÖ Acquired</option>
                        </select>
                    </div>
                `;
            } else {
                // Show Add Button
                pfHtml = `
                    <button onclick="addToPortfolio('${props.id}')" 
                        class="mt-2 w-full py-2 bg-gray-700 hover:bg-gray-600 border border-white/10 rounded-lg text-sm font-semibold transition-colors flex items-center justify-center gap-2 text-gray-300">
                        <span>‚òÜ Add to Portfolio</span>
                    </button>
                `;
            }

            // Inject
            const existingPf = document.getElementById('pfActions');
            if (existingPf) existingPf.remove(); // cleanup old

            const actionContainer = document.createElement('div');
            actionContainer.id = 'pfActions';
            actionContainer.innerHTML = pfHtml;
            document.getElementById('parcelInfo').appendChild(actionContainer);


            // Allow re-processing (Always enabled)
            if (props.slope_mean != null && props.slope_mean !== "N/A") {
                btn.innerHTML = "<span>üîÑ Re-Analyze with Agent</span>";
                btn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else {
                btn.innerHTML = "<span>‚ú® Ask Agent to Analyze</span>";
                btn.classList.remove('opacity-50', 'cursor-not-allowed');
            }
        }

        // --- PORTFOLIO LOGIC ---
        let PORTFOLIO_DATA = { saved_parcels: {} };

        async function initPortfolio() {
            try {
                const res = await fetch('/api/portfolio');
                if (res.ok) {
                    PORTFOLIO_DATA = await res.json();
                    renderPortfolio();
                }
            } catch (e) { console.error("PF Init fail", e); }
        }

        function renderPortfolio() {
            const list = document.getElementById('pfList');
            const count = document.getElementById('pfCount');
            const ids = Object.keys(PORTFOLIO_DATA.saved_parcels);

            count.innerText = ids.length;

            if (ids.length === 0) {
                list.innerHTML = `<div class="text-xs text-gray-500 italic">No saved plots.</div>`;
                return;
            }

            list.innerHTML = ids.map(id => {
                const data = PORTFOLIO_DATA.saved_parcels[id];
                const statusIcons = {
                    'starred': '‚≠ê',
                    'owner_requested': 'üì´',
                    'owner_contacted': 'üó£Ô∏è',
                    'negotiating': 'ü§ù',
                    'acquired': '‚úÖ'
                };
                return `
                    <div class="group flex justify-between items-center bg-gray-800/50 p-2 rounded hover:bg-gray-700 cursor-pointer" onclick="zoomToParcel('${id}')">
                        <div class="flex flex-col">
                            <span class="text-xs font-mono text-gray-300">${id}</span>
                            <span class="text-[10px] text-gray-500">${statusIcons[data.status] || '‚≠ê'} ${data.status}</span>
                        </div>
                        <button onclick="event.stopPropagation(); removeFromPortfolio('${id}')" class="text-gray-600 hover:text-red-400 px-1">‚úï</button>
                    </div>
                `;
            }).join('');
        }

        async function addToPortfolio(id) {
            try {
                const res = await fetch('/api/portfolio/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: id, status: 'starred' })
                });
                if (res.ok) {
                    const json = await res.json();
                    PORTFOLIO_DATA = json.portfolio;
                    renderPortfolio();
                    // Refreshes the panel to show the status dropdown
                    const feat = parcelsData.features.find(f => f.properties.id === id);
                    if (feat) selectParcel(feat);
                }
            } catch (e) { console.error(e); }
        }

        async function updateStatus(id, status) {
            try {
                const res = await fetch('/api/portfolio/add', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: id, status: status })
                });
                if (res.ok) {
                    const json = await res.json();
                    PORTFOLIO_DATA = json.portfolio;
                    renderPortfolio();
                }
            } catch (e) { console.error(e); }
        }

        async function removeFromPortfolio(id) {
            if (!confirm("Remove from portfolio?")) return;
            try {
                const res = await fetch('/api/portfolio/remove', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: id })
                });
                if (res.ok) {
                    const json = await res.json();
                    PORTFOLIO_DATA = json.portfolio;
                    renderPortfolio();

                    // Refresh panel if currently selected
                    const currentId = document.getElementById('pId').innerText;
                    if (currentId === id) {
                        const feat = parcelsData.features.find(f => f.properties.id === id);
                        if (feat) selectParcel(feat);
                    }
                }
            } catch (e) { console.error(e); }
        }

        function zoomToParcel(id) {
            if (!parcelsData) return;
            const feat = parcelsData.features.find(f => f.properties.id === id);
            if (feat) {
                selectParcel(feat);
                const bbox = turf.bbox(feat);
                map.fitBounds(bbox, { maxZoom: 18, padding: 100 });
            }
        }

        function highlightPortfolio() {
            const ids = Object.keys(PORTFOLIO_DATA.saved_parcels);
            if (ids.length === 0) return;

            // Highlight
            map.setFilter('parcels-highlight', ['in', 'id', ...ids]);

            // Zoom to them
            if (parcelsData) {
                const features = parcelsData.features.filter(f => ids.includes(f.properties.id));
                if (features.length > 0) {
                    const bbox = turf.bbox({ type: "FeatureCollection", features: features });
                    map.fitBounds(bbox, { padding: 50 });
                }
            }
        }

        // Removed old highlightUserPlots function in favor of dynamic one or just kept as legacy? 
        // User asked to "select and add", so dynamic is better.
        // We can remove the old highlightUserPlots function or just leave it unused.

        // Initialize
        initPortfolio();

        // --- FILTER LOGIC ---
        function filterMapByCommune(code) {
            if (!map.getLayer('parcels-fill')) return;

            if (code === 'all') {
                map.setFilter('parcels-fill', null);
                map.setFilter('parcels-line', null);

                // Keep highlights visible but maybe filtered? No, highlight should always show if selected
                // But we should likely clear selection if it's hidden. 
                // For simplicity, just reset base filters.
            } else {
                // Filter by ID prefix. ID structure: {commoncode}000{Section}{Num}
                // e.g. 73057... 
                // Mapbox 'like' filter? Or checking 'commune' property if reliable. 
                // Let's rely on 'id' prefix using standard expression
                // ['^', ['get', 'id'], code] -> startswith? 
                // Actually Mapbox GL JS doesn't have 'startswith' operator directly in older versions?
                // But we can use 'slice'. 
                // Or just: ['==', ['slice', ['get', 'id'], 0, 5], code]

                const filterExpr = ['==', ['slice', ['get', 'id'], 0, 5], code];

                map.setFilter('parcels-fill', filterExpr);
                map.setFilter('parcels-line', filterExpr);

                // Fly to commune center
                const centers = {
                    '73057': [6.57, 45.45],
                    '73284': [6.53, 45.47],
                    '73055': [6.65, 45.44],
                    '73227': [6.63, 45.42] // Le Praz
                };
                if (centers[code]) {
                    map.flyTo({ center: centers[code], zoom: 14 });
                }
            }

            // --- Update UI Text & Stats ---
            const names = {
                'all': 'All Communes',
                'debug': 'All (Debug)',
                '73057': 'Brides-les-Bains',
                '73284': 'Salins-les-Thermes',
                '73055': 'Bozel',
                '73227': 'Courchevel (Le Praz)'
            };
            const subtitle = document.getElementById('appSubtitle');
            if (subtitle) subtitle.innerText = names[code] || code;

            // Recalculate Stats locally
            if (parcelsData) {
                let filteredFeatures = parcelsData.features;
                if (code !== 'all' && code !== 'debug') {
                    filteredFeatures = filteredFeatures.filter(f => f.properties.id.startsWith(code)); // or slice check
                }

                document.getElementById('totalParcelCount').innerText = filteredFeatures.length;
                if (filteredFeatures.length > 0) {
                    const totalArea = filteredFeatures.reduce((acc, f) => acc + (f.properties.contenance || 0), 0);
                    // Note: 'contenance' is in raw data, 'total_area_sqm' in analysis. Raw data uses 'contenance'.
                    // Analysis file has 'total_area_sqm', raw has 'contenance'. Need safe access.
                    // The combined data might have mixed properties. 'contenance' is standard Cadastre.
                    const avg = totalArea / filteredFeatures.length;
                    document.getElementById('avgSize').innerText = Math.round(avg);
                } else {
                    document.getElementById('avgSize').innerText = "0";
                }
            }

            // Re-fit bounds to visible features if possible?
            // This is heavy on client side with 60k points. Let user pan.
        }

        // --- DOCUMENT UPLOAD LOGIC ---
        async function uploadDocument() {
            const fileInput = document.getElementById('docFile');
            if (fileInput.files.length === 0) return alert("Select a file");

            const btn = document.getElementById('btnUpload');
            const keyInput = document.getElementById('geminiKey');
            const apiKey = keyInput.value.trim();

            // Save key if provided
            if (apiKey) {
                localStorage.setItem('gemini_api_key', apiKey);
            }

            btn.innerHTML = "ü§ñ AI Analyzing Document...";
            btn.disabled = true;

            const formData = new FormData();
            formData.append('file', fileInput.files[0]);
            if (apiKey) formData.append('api_key', apiKey);

            try {
                const res = await fetch('/api/upload-doc', {
                    method: 'POST',
                    body: formData
                });
                const json = await res.json();

                if (res.ok) {
                    // Open Viewer
                    document.getElementById('uploadDocModal').classList.add('hidden');
                    openDocViewer(json);
                } else {
                    alert("Upload failed: " + json.error);
                }
            } catch (e) {
                console.error(e);
                alert("Error uploading");
            } finally {
                btn.innerHTML = "üöÄ Upload & Analyze";
                btn.disabled = false;
            }
        }

        function checkKeyWarning() {
            const input = document.getElementById('geminiKey');
            const warn = document.getElementById('apiWarning');
            if (input.value.trim() === "") {
                warn.classList.remove('hidden');
            } else {
                warn.classList.add('hidden');
            }
        }

        // Auto-fill Key on Init
        document.addEventListener('DOMContentLoaded', () => {
            const savedKey = localStorage.getItem('gemini_api_key');
            if (savedKey) {
                const input = document.getElementById('geminiKey');
                if (input) input.value = savedKey;
            }
            checkKeyWarning();
        });

        function openDocViewer(data) {
            const viewer = document.getElementById('docViewer');
            const pdf = document.getElementById('pdfFrame');
            const img = document.getElementById('imgFrame');
            const cont = document.getElementById('docSuggestions');
            const list = document.getElementById('docIdsList');

            viewer.classList.remove('hidden');

            // Content
            if (data.filename.toLowerCase().endsWith('.pdf')) {
                pdf.src = data.url;
                pdf.classList.remove('hidden');
                img.classList.add('hidden');
            } else {
                img.src = data.url;
                img.classList.remove('hidden');
                pdf.classList.add('hidden');
            }

            // Suggestions
            list.innerHTML = "";

            if (data.found_ids && data.found_ids.length > 0) {
                cont.classList.remove('hidden');

                // Show Section if found
                const label = cont.querySelector('.uppercase');
                if (data.section) {
                    label.innerText = `Detected in Section ${data.section}:`;
                } else {
                    label.innerText = "Detected Plots:";
                }

                data.found_ids.forEach(id => {
                    const btn = document.createElement('button');
                    btn.className = "px-2 py-1 bg-blue-600 hover:bg-blue-500 text-white rounded text-xs font-mono";
                    btn.innerText = id;
                    btn.onclick = () => findAndSelectPartial(id, data.section, data.commune_code);
                    list.appendChild(btn);
                });
            } else {
                cont.classList.add('hidden');
            }
        }

        function closeDocViewer() {
            document.getElementById('docViewer').classList.add('hidden');
        }

        function toggleDocOpacity() {
            const v = document.getElementById('docViewer');
            if (v.classList.contains('opacity-50')) {
                v.classList.remove('opacity-50');
            } else {
                v.classList.add('opacity-50');
            }
        }

        // --- REFACTORED SEARCH LOGIC ---
        function findParcelMatch(num, section, communeCode) {
            if (!parcelsData) return null;

            // Normalize
            let searchNum = num.toString().trim();
            let match = null;

            if (communeCode) {
                // Specialized search with Commune Code prefix
                const prefix = communeCode;
                const padded = searchNum.padStart(4, '0');
                const sec = section ? section.toUpperCase() : "";

                match = parcelsData.features.find(f => {
                    const id = f.properties.id;
                    if (!id.startsWith(prefix)) return false;

                    if (sec) {
                        const target1 = sec + padded;
                        const target2 = sec + searchNum;
                        return id.endsWith(target1) || id.endsWith(target2);
                    } else {
                        return id.endsWith(padded) || id.endsWith(searchNum);
                    }
                });
            } else {
                // Fallback / Global Search
                const padded = searchNum.padStart(4, '0');
                if (section) {
                    const sec = section.toUpperCase();
                    const target1 = sec + padded;
                    const target2 = sec + searchNum;
                    match = parcelsData.features.find(f => f.properties.id.endsWith(target1) || f.properties.id.endsWith(target2));
                } else {
                    match = parcelsData.features.find(f => {
                        const fid = f.properties.numero; // If available
                        return fid == searchNum || fid == padded || f.properties.id.endsWith(searchNum) || f.properties.id.endsWith(padded);
                    });
                }
            }
            return match;
        }

        function findAndSelectPartial(num, section, communeCode) {
            const match = findParcelMatch(num, section, communeCode);

            if (match) {
                console.log("Found match:", match.properties.id);
                selectParcel(match);

                if (window.turf) {
                    const bbox = turf.bbox(match);
                    map.fitBounds(bbox, { maxZoom: 19, padding: 100 });
                }
            } else {
                let msg = "Parcel " + num + " not found.";
                if (section) msg += " (Section " + section + ")";
                if (communeCode) msg += " (Commune " + communeCode + ")";
                console.warn(msg);
                alert(msg);
            }
        }


        function highlightUserPlots() {
            const targetIds = [
                "730570000C1228",
                "730570000C1221",
                "730570000C1226",
                "730570000C1230",
                "730570000C1042",
                "730570000C1043",
                "730570000C1045",
                "730570000C1044"
            ];

            // Highlight
            map.setFilter('parcels-highlight', ['in', 'id', ...targetIds]);

            // Zoom to them
            if (parcelsData) {
                const features = parcelsData.features.filter(f => targetIds.includes(f.properties.id));
                if (features.length > 0) {
                    const bbox = turf.bbox({ type: "FeatureCollection", features: features });
                    map.fitBounds(bbox, { padding: 50 });

                    // Show info for the group? Or just the first one?
                    // Let's just update the panel to show "Group Selection"
                    document.getElementById('emptyState').classList.add('hidden');
                    document.getElementById('parcelInfo').classList.remove('hidden');
                    document.getElementById('pId').innerText = "Group Selection";

                    const totalArea = features.reduce((acc, f) => acc + f.properties.total_area_sqm, 0);
                    document.getElementById('pArea').innerText = Math.round(totalArea) + " m¬≤ (Total)";
                    document.getElementById('pSlope').innerText = "Various";
                    document.getElementById('pOwner').innerText = "Various";
                    document.getElementById('pBuild').innerText = "--";
                    document.getElementById('pEnrichment').innerHTML = "<div class='text-xs text-gray-400'>Showing 8 plots between bridges.</div>";
                }
            }
        }

        function resetSelection() {
            map.setFilter('parcels-highlight', ['==', 'id', '']);
            document.getElementById('emptyState').classList.remove('hidden');
            document.getElementById('parcelInfo').classList.add('hidden');

            // --- RESET TITLE & SEARCH ---
            const filterVal = document.getElementById('communeFilter').value;
            let defName = "All Communes";
            if (filterVal === '73057') defName = "Brides-les-Bains";
            else if (filterVal === '73284') defName = "Salins-les-Thermes";
            else if (filterVal === '73055') defName = "Bozel";
            else if (filterVal === '73227') defName = "Courchevel (Le Praz)";

            const sub = document.getElementById('appSubtitle');
            if (sub) sub.innerText = defName;

            const searchInput = document.getElementById('addressSearch');
            const clearBtn = document.getElementById('clearAddrBtn');
            if (searchInput) searchInput.value = "";
            if (clearBtn) clearBtn.classList.add('hidden');
        }

        async function fetchZoningIntersection(parcelFeature) {
            const bbox = turf.bbox(parcelFeature);
            // Expand BBOX slightly 
            const s = bbox[1] - 0.001;
            const w = bbox[0] - 0.001;
            const n = bbox[3] + 0.001;
            const e = bbox[2] + 0.001;

            // NEW URL: Geoplateforme
            const wfsBase = "https://data.geopf.fr/wfs/ows";

            // Sanitize params
            const sW = w.toFixed(6);
            const sS = s.toFixed(6);
            const sE = e.toFixed(6);
            const sN = n.toFixed(6);

            // WFS 2.0.0 Params
            const params = new URLSearchParams({
                'service': 'WFS',
                'version': '2.0.0',
                'request': 'GetFeature',
                'typeName': 'wfs_du:zone_urba', // Correct Typename for new Global GPU layer
                'outputFormat': 'json',
                'srsName': 'EPSG:4326',
                // FIX: Geoplateforme WFS 2.0 with EPSG:4326 seems to want LON,LAT order based on debug script
                // even though spec often says otherwise. We trust the debug script result (Found 35 features).
                'bbox': `${sW},${sS},${sE},${sN},EPSG:4326`
            });

            // Re-enable Proxy (corsproxy.io) to ensure no CORS blocking on new URL
            const targetUrl = `${wfsBase}?${params.toString()}`;
            const proxyUrl = `https://corsproxy.io/?${encodeURIComponent(targetUrl)}`;

            try {
                console.log("Fetching Geoplateforme via Proxy:", proxyUrl);
                const res = await fetch(proxyUrl);

                if (!res.ok) {
                    const txt = await res.text();
                    throw new Error(`HTTP ${res.status}: ${txt.substring(0, 100)}`);
                }

                const data = await res.json();

                // --- HEURISTIC FALLBACK ---
                // If WFS returns no data, we ESTIMATE based on Slope/Location.
                if (!data.features || data.features.length === 0) {
                    console.warn("WFS Empty - Using Heuristic");
                    // Heuristic: If Slope < 30%, assume constructible for now (Client Request for Estimation)
                    // In reality, this should be "Possible", but user asked for "Estimations"
                    const slope = parcelFeature.properties.slope_mean || 0;
                    const isLikely = slope < 30;

                    const estPct = parseFloat(document.getElementById('recEstPercent').value) || 80;
                    const factor = estPct / 100.0;

                    const estArea = isLikely ? Math.round(parcelFeature.properties.total_area_sqm * factor) : 0;

                    return {
                        isBuildable: isLikely,
                        buildableAreaSqm: estArea,
                        zone: "Estimated",
                        labels: "Inferred from Terrain (WFS Missing)",
                        debugKeys: "WFS Empty - Heuristic Applied"
                    };
                }

                // Debug keys
                let availableKeys = "None";
                if (data.features.length > 0) {
                    availableKeys = Object.keys(data.features[0].properties).join(", ");
                }

                let totalBuildableArea = 0;
                let primaryZone = "Unknown";
                let allZones = new Set();

                let parcelPoly = parcelFeature;
                if (parcelFeature.geometry.type === "MultiPolygon") {
                    parcelPoly = turf.polygon(parcelFeature.geometry.coordinates[0]);
                }

                for (const zoneFeat of data.features) {
                    // FIX: WFS 2.0 might return Lat,Lon order (EPSG:4326) even in GeoJSON.
                    // Check first coordinate. Brides-les-Bains: Lon ~6.5, Lat ~45.5.
                    // If [0] > 40, it's flipped.
                    let geometry = zoneFeat.geometry;
                    if (geometry.type === "Polygon" || geometry.type === "MultiPolygon") {
                        const p = geometry.type === "Polygon" ? geometry.coordinates[0][0] : geometry.coordinates[0][0][0];
                        if (p && p[0] > 40 && p[1] < 10) {
                            // Flip needed. Using Turf 'coordEach' or simple manual map would be best but let's try a simple re-mapping if it's just Polygon.
                            // Actually, let's just use turf.flip if available or manual.
                            // Manual Deep Swap for Polygon/MultiPolygon
                            const flipRing = ring => ring.map(c => [c[1], c[0]]);
                            if (geometry.type === "Polygon") {
                                geometry.coordinates = geometry.coordinates.map(flipRing);
                            } else if (geometry.type === "MultiPolygon") {
                                geometry.coordinates = geometry.coordinates.map(poly => poly.map(flipRing));
                            }
                        }
                    }

                    const props = zoneFeat.properties;

                    // Helper
                    const getProp = (keys) => {
                        for (const k of keys) {
                            if (props[k] !== undefined) return props[k];
                            if (props[k.toUpperCase()] !== undefined) return props[k.toUpperCase()];
                            if (props[k.toLowerCase()] !== undefined) return props[k.toLowerCase()];
                        }
                        return null;
                    };

                    const type = getProp(['typezone', 'TYPEZONE', 'libelle', 'LIBELLE']);
                    const label = getProp(['libelle', 'LIBELLE', 'libelong']);

                    if (!type) continue;

                    if (["U", "AU", "Urbain", "A urbaniser"].some(t => type.includes(t))) {
                        try {
                            const intersection = turf.intersect(parcelPoly, zoneFeat); // zoneFeat now has Potentially Flipped Geometry
                            if (intersection) {
                                totalBuildableArea += turf.area(intersection);
                                primaryZone = type;
                                allZones.add(label || type);
                            }
                        } catch (err) { }
                    } else {
                        try {
                            const intersection = turf.intersect(parcelPoly, zoneFeat);
                            if (intersection) {
                                allZones.add(label || type);
                                if (primaryZone === "Unknown") primaryZone = type;
                            }
                        } catch (e) { }
                    }
                }

                // --- FINAL LOGIC ADJUSTMENT ---
                // If we found Features, but Intersection resulted in 0 area (Mismatch/Gap),
                // OR if the zone found was not buildable,
                // BUT the User wants "Estimations", we should check Slope logic again as a "Soft Fallback".

                if (totalBuildableArea < 10) {
                    // Check if we at least found a Zone Label to report
                    const zoneFound = primaryZone !== "Unknown" ? primaryZone : "Unknown";

                    // Run Estimate
                    const slope = parcelFeature.properties.slope_mean || 0;
                    const isLikely = slope < 30;
                    const estArea = isLikely ? Math.round(parcelFeature.properties.total_area_sqm * 0.8) : 0;

                    // If we found a zone (e.g. N - Naturelle) and it's definitely NOT buildable, we should say NO.
                    // But if Unknown, or if user insists on estimation, we provide context.

                    if (isLikely && zoneFound === "Unknown") {
                        // Case: Features returned but no intersection (Geometry mismatch). 
                        // Respond with Estimate.
                        return {
                            isBuildable: true,
                            buildableAreaSqm: estArea,
                            zone: "Estimated (Geo Mismatch)",
                            labels: `Keys found: ${availableKeys}`, // Keep debug info
                            debugKeys: availableKeys
                        };
                    }
                }

                return {
                    isBuildable: totalBuildableArea > 10,
                    buildableAreaSqm: Math.round(totalBuildableArea),
                    zone: primaryZone === "Unknown" ? "Undefined" : primaryZone,
                    labels: Array.from(allZones).join(", "),
                    debugKeys: availableKeys
                };

            } catch (e) {
                console.error("WFS Error:", e);
                // Fallback on Error too
                const slope = parcelFeature.properties.slope_mean || 0;
                const isLikely = slope < 30;
                const estArea = isLikely ? Math.round(parcelFeature.properties.total_area_sqm * 0.8) : 0;

                return {
                    isBuildable: isLikely,
                    buildableAreaSqm: estArea,
                    zone: "Estimated (Sys Error)",
                    labels: "Inferred from Terrain",
                    error: e.message
                };
            }
        }

        async function askAgent(id) {
            const btn = document.getElementById('btnAgent');
            // Breathing Animation
            btn.innerHTML = `
                <div class="flex items-center justify-center gap-2">
                    <div class="w-3 h-3 bg-purple-400 rounded-full animate-breathe"></div>
                    <span class="text-purple-200">Analyzing...</span>
                </div>`;

            try {
                // 1. Server Analysis (Slope, Owner)
                const res = await fetch('/agent/fetch-parcel-data', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: id })
                });
                const json = await res.json();

                if (res.ok) {
                    btn.innerHTML = `
                        <div class="flex items-center justify-center gap-2">
                            <div class="w-3 h-3 bg-blue-400 rounded-full animate-breathe"></div>
                            <span class="text-blue-200">Calculating...</span>
                        </div>`;

                    // Update Slope
                    const slopePct = json.slope;
                    const slopeDeg = Math.round(Math.atan(slopePct / 100) * (180 / Math.PI));
                    document.getElementById('pSlope').innerText = `${slopePct}% (${slopeDeg}¬∞)`;

                    // 2. Client Analysis (Zoning Intersection)
                    // We need the geometry of the parcel. checking parcelsData
                    const feature = parcelsData.features.find(f => f.properties.id === id);

                    if (feature) {
                        // UPDATE MEMORY
                        feature.properties.slope_mean = json.slope;
                        feature.properties.address = json.address;
                        feature.properties.est_price_m2 = json.est_price_m2;
                        feature.properties.dist_to_hub = json.dist_to_hub;
                        feature.properties.owner_status = json.owner_status;
                        feature.properties.owner_email = json.owner_email;

                        // Force update UI
                        const encDiv = document.getElementById('pEnrichment');
                        encDiv.innerHTML = "";

                        if (json.address) {
                            encDiv.innerHTML += `
                                <div class="flex flex-col">
                                    <span class="text-gray-400 text-xs uppercase">üìç Address</span>
                                    <span class="text-white text-sm">${json.address}</span>
                                </div>`;
                        }
                        if (json.dist_to_hub) {
                            encDiv.innerHTML += `
                                <div class="flex flex-col">
                                    <span class="text-gray-400 text-xs uppercase">üö° Distance to Hub</span>
                                    <span class="text-white text-sm">${json.dist_to_hub}m to Olympe</span>
                                </div>`;
                        }
                        if (json.est_price_m2) {
                            const totalEst = (json.est_price_m2 * feature.properties.total_area_sqm) / 1000;
                            encDiv.innerHTML += `
                                <div class="flex flex-col">
                                    <span class="text-gray-400 text-xs uppercase">üí∞ Est. Market Price</span>
                                    <span class="text-green-400 text-sm font-bold">‚Ç¨${json.est_price_m2}/m¬≤ (~‚Ç¨${Math.round(totalEst)}k)</span>
                                </div>`;
                        }

                        const zoning = await fetchZoningIntersection(feature);
                        let buildHtml = "<span class='text-gray-400'>Unknown</span>"; // Default

                        if (zoning) {
                            if (zoning.error) {
                                buildHtml = `<span class='text-red-500 font-bold'>Error: ${zoning.error}</span>`;
                            } else if (zoning.isBuildable) {
                                const totalArea = feature.properties.total_area_sqm;
                                const percent = Math.round((zoning.buildableAreaSqm / totalArea) * 100);
                                buildHtml = `
                                <div class='flex flex-col'>
                                    <span class='text-green-400 font-bold'>YES (${zoning.buildableAreaSqm} m¬≤)</span>
                                    <span class='text-xs text-gray-400'>${percent}% of plot (Zone ${zoning.zone})</span>
                                    <span class='text-[10px] text-gray-500 truncate'>${zoning.labels}</span>
                                </div>`;
                            } else {
                                // NOT BUILDABLE
                                const subText = zoning.zone === "Undefined" ? `Keys found: ${zoning.debugKeys}` : `Zone ${zoning.zone}`;
                                const color = zoning.zone === "Undefined" ? "text-orange-400" : "text-red-500";

                                let reason = zoning.labels;
                                if (feature.properties.slope_mean > 30) reason += " (Steep Slope)";

                                buildHtml = `
                                <div class='flex flex-col'>
                                    <span class='${color} font-bold'>NO (0 m¬≤)</span>
                                    <span class='text-[10px] text-gray-400'>${subText}</span>
                                    <span class='text-[10px] text-gray-500 truncate'>${reason}</span>
                                </div>`;
                            }

                            // Save to Memory
                            feature.properties.buildable_area_sqm = zoning.isBuildable ? zoning.buildableAreaSqm : 0;
                        }

                        document.getElementById('pBuild').innerHTML = buildHtml;
                    } else {
                        document.getElementById('pBuild').innerHTML = "<span class='text-orange-400 font-bold'>Zoning Network Error</span>";
                    }


                    // Handle Owner
                    if (json.owner_status) {
                        document.getElementById('pOwner').innerText = json.owner_status;

                        const copyBtn = document.getElementById('btnCopyRequest');
                        copyBtn.classList.remove('hidden');
                        copyBtn.innerText = "üìã Copy official request letter";
                        copyBtn.onclick = () => {
                            navigator.clipboard.writeText(json.owner_request_text).then(() => {
                                copyBtn.innerText = "Values Copied to Clipboard!";
                                setTimeout(() => copyBtn.innerText = "üìã Copy official request letter", 2000);
                            });
                        };

                        // Handle Email
                        if (json.owner_email) {
                            let emailDiv = document.getElementById('ownerEmailDiv');
                            if (!emailDiv) {
                                emailDiv = document.createElement('div');
                                emailDiv.id = 'ownerEmailDiv';
                                emailDiv.className = "mt-2 text-xs text-center text-gray-400";
                                document.getElementById('parcelInfo').appendChild(emailDiv);
                            }
                            emailDiv.innerHTML = `Send to: <a href="mailto:${json.owner_email}" class="text-blue-400 hover:underline">${json.owner_email}</a>`;
                            emailDiv.innerHTML = `Send to: <a href="mailto:${json.owner_email}" class="text-blue-400 hover:underline">${json.owner_email}</a>`;
                        }
                    }

                    // Add Google Button
                    if (json.center_lat) {
                        let gBtn = document.getElementById('btnGoogle');
                        if (!gBtn) {
                            gBtn = document.createElement('a');
                            gBtn.id = 'btnGoogle';
                            gBtn.target = "_blank";
                            gBtn.className = "mt-2 block w-full py-2 bg-gray-700 hover:bg-gray-600 rounded text-xs text-center text-white border border-gray-600";
                            gBtn.innerText = "üåè Open in Google Street View";
                            document.getElementById('parcelInfo').appendChild(gBtn);
                        }
                        gBtn.href = `https://www.google.com/maps?q=&layer=c&cbll=${json.center_lat},${json.center_lon}`;
                    }

                    btn.innerText = "Analysis Complete";
                    loadData();

                } else {
                    btn.innerText = "Agent Failed";
                    alert("Agent Error: " + json.error);
                }
            } catch (e) {
                btn.innerText = "Network Error";
                alert(e);
            }
        }

        // Clear copy button on selection change
        function clearCopyBtn() {
            const btn = document.getElementById('btnCopyRequest');
            if (btn) btn.classList.add('hidden');
        }

        // --- RECOMMENDATION SYSTEM ---
        function openRecModal() {
            document.getElementById('recModal').classList.remove('hidden');

            // Sync Dropdown with Current View ONLY if it hasn't been set yet (or user just started app)
            // Actually, we want persistence, so we DON'T sync it every Open.
            // We only set it if it's currently "all" (default) to match map context maybe?
            // User requested: "I would like to still my search details"
            // So we REMOVE the forced update.

            /* 
            const sel = document.getElementById('recScopeSelect');
            if (sel) {
                if (APP_STATE.commune === 'debug') sel.value = 'all';
                else sel.value = APP_STATE.commune;
            } 
            */

            findBestLands(); // Auto-load
        }
        function closeRecModal() {
            document.getElementById('recModal').classList.add('hidden');
        }

        function findBestLands(resetQueue = true) {
            try {
                if (!parcelsData) return;

                if (resetQueue) analysisQueue = [];

                const minArea = parseFloat(document.getElementById('recMinArea').value) || 0;
                const maxArea = parseFloat(document.getElementById('recMaxArea').value) || 99999999;
                const maxSlope = parseFloat(document.getElementById('recMaxSlope').value) || 100;

                // Scope Logic
                const scopeEl = document.getElementById('recScopeSelect');
                const scopeVal = scopeEl ? scopeEl.value : 'all';

                // 1. Calculate Global Median Price/m2 from knowns
                const knownPrices = parcelsData.features
                    .map(f => f.properties.est_price_m2)
                    .filter(p => p !== undefined && p !== null);

                let globalMedianPrice = 150; // Default fallback
                if (knownPrices.length > 0) {
                    knownPrices.sort((a, b) => a - b);
                    globalMedianPrice = knownPrices[Math.floor(knownPrices.length / 2)];
                }

                // Score and Filter
                const results = parcelsData.features
                    .map(f => {
                        const area = parseFloat(f.properties.total_area_sqm) || 0; // Ensure Number
                        let slope = f.properties.slope_mean;

                        // Parse Slope safely
                        if (slope !== null && slope !== undefined && slope !== "N/A") {
                            slope = parseFloat(slope);
                        } else {
                            slope = null; // Mark as unknown
                        }

                        // Filter Hard Constraints
                        if (area < minArea) return null;
                        if (area > maxArea) return null;

                        // Only filter slope if we actually KNOW it
                        if (slope !== null && slope > maxSlope) return null;

                        // Filter by Commune Scope Dropdown
                        if (scopeVal !== 'all') {
                            if (!f.properties.id.startsWith(scopeVal)) return null;
                        }

                        // --- SCORING ENGINE ---
                        // Weighted approach: Accessibility + Price + Validity

                        let score = 10;

                        // 1. Slope Score (Max 4 pts)
                        if (slope !== null) {
                            const sScore = Math.max(0, 4 - (slope / 7.5));
                            score += sScore;
                        } else {
                            score -= 2; // Penalty for unknown
                        }

                        // 2. Accessibility Score (Distance to Olympe) (Max 5 pts)
                        const dist = f.properties.dist_to_hub;
                        if (dist) {
                            const dScore = Math.max(0, 5 - (dist / 400));
                            score += dScore;
                        } else {
                            score -= 1; // Unknown distance
                        }

                        // 3. Price Score (Value) (Max 5 pts)
                        let priceVal = f.properties.est_price_m2 || globalMedianPrice;
                        f.properties.projected_price_m2 = priceVal; // Store for display
                        f.properties.is_projected_price = !f.properties.est_price_m2;

                        const pScore = Math.max(0, 5 - (priceVal / 200));
                        score += pScore;

                        // Area Bonus (Small)
                        if (area > 1000) score += 1;

                        return { feature: f, score: score, slopeVal: slope };
                    })
                    .filter(item => item !== null)
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 100); // Top 100

                // UI Feedback
                const statusDiv = document.getElementById('recStatus');
                if (statusDiv) {
                    if (results.length === 0) {
                        statusDiv.innerText = `No lands found (Scope: ${scopeVal})`;
                        statusDiv.classList.add('text-red-400');
                        statusDiv.classList.remove('text-blue-400', 'animate-pulse');
                    } else {
                        statusDiv.innerText = `Found ${results.length} top matches`;
                        statusDiv.classList.add('text-blue-400');
                        statusDiv.classList.remove('text-red-400', 'animate-pulse');
                    }
                }

                renderRecResults(results);

                // Queue Up Unknowns for Analysis (Top 20 to avoid spamming)
                const candidates = results
                    .filter(r => r.slopeVal === null)
                    .slice(0, 20)
                    .map(r => r.feature.properties.id);

                // Add unique to queue
                let added = false;
                candidates.forEach(id => {
                    if (!analysisQueue.includes(id)) {
                        analysisQueue.push(id);
                        added = true;
                    }
                });

                if (added && !isAnalyzing) {
                    processAnalysisQueue();
                }

            } catch (e) {
                alert("FindBestLands Crash: " + e.message);
                console.error(e);
            }
        }

        function renderRecResults(results) {
            const container = document.getElementById('recResults');
            container.innerHTML = "";
            container.classList.remove('hidden');

            if (results.length === 0) {
                container.innerHTML = "<div class='text-gray-400 text-xs text-center'>No matching lands found.</div>";
                return;
            }

            results.forEach((item, idx) => {
                const f = item.feature;
                const p = f.properties;
                const el = document.createElement('div');
                el.className = "flex justify-between items-center bg-gray-800 p-2 rounded hover:bg-gray-700 cursor-pointer border border-gray-700";
                el.onclick = () => {
                    selectParcel(f);
                    closeRecModal();

                    // Fly to it (On Top)
                    if (window.turf) {
                        const bbox = turf.bbox(f);
                        map.fitBounds(bbox, {
                            padding: 100,
                            maxZoom: 19,
                            pitch: 0, // Top-down view
                            bearing: 0 // North up
                        });
                    } else {
                        // Fallback if turf not ready
                        if (f.geometry.type === 'MultiPolygon' || f.geometry.type === 'Polygon') {
                            const coords = f.geometry.coordinates[0][0][0] ? f.geometry.coordinates[0][0][0] : f.geometry.coordinates[0][0];
                            map.flyTo({ center: coords, zoom: 18, pitch: 0 });
                        }
                    }
                };

                const areaDisplay = Math.round(p.total_area_sqm) + " m¬≤";

                let slopeDisplay = "<span class='text-gray-500'>Slope: ?</span>";
                if (item.slopeVal !== null) {
                    slopeDisplay = `<span class='text-green-400'>Slope: ${Math.round(item.slopeVal)}%</span>`;
                }

                let subDetails = "";
                if (p.address) subDetails += `<div class='truncate text-gray-500'>${p.address}</div>`;
                if (p.dist_to_hub) {
                    const hubName = getHub(p.id).name;
                    subDetails += `<div class='text-gray-500'>${p.dist_to_hub}m to ${hubName}</div>`;
                }

                // Price Estimate (Real or Projected)
                const priceM2 = p.est_price_m2 || p.projected_price_m2;
                if (priceM2) {
                    const totalEst = (priceM2 * p.total_area_sqm) / 1000; // kEUR

                    if (!p.is_projected_price) {
                        // Real DVF
                        const priceColor = priceM2 < 200 ? 'text-green-400' : 'text-yellow-400';
                        subDetails += `<div class='${priceColor} font-bold'>‚Ç¨${priceM2}/m¬≤ (~‚Ç¨${Math.round(totalEst)}k)</div>`;
                    } else {
                        // Projected
                        subDetails += `<div class='text-gray-600 italic'>Est. ~‚Ç¨${priceM2}/m¬≤ (Projected)</div>`;
                    }
                }

                el.innerHTML = `
                    <div class="flex gap-3 items-center w-full overflow-hidden">
                        <div class="text-xl font-bold text-gray-600 font-mono">#${idx + 1}</div>
                        <div class="flex-1 min-w-0">
                            <div class="text-sm font-bold text-white">#${p.id}</div>
                            <div class="text-xs text-gray-400">${areaDisplay} ‚Ä¢ ${slopeDisplay}</div>
                            <div class="text-[10px] mt-1">${subDetails}</div>
                        </div>
                    </div>
                    <div class="text-xs font-mono text-blue-400 whitespace-nowrap pl-2">
                        ${Math.round(item.score * 10) / 10}
                    </div>
                `; container.appendChild(el);
            });
        }

        // --- PROACTIVE AGENT QUEUE ---
        async function processAnalysisQueue() {
            if (isAnalyzing || analysisQueue.length === 0) return;

            isAnalyzing = true;
            const statusDiv = document.getElementById('recStatus');

            while (analysisQueue.length > 0) {
                // Check if modal is still open (stop if closed)
                if (document.getElementById('recModal').classList.contains('hidden')) {
                    analysisQueue = []; // Clear queue
                    break;
                }

                const id = analysisQueue.shift();
                console.log("Agent Proactive Analysis for:", id);

                // Show status
                if (statusDiv) statusDiv.innerText = `Agent analyzing parcel #${id}...`;

                try {
                    // Reuse Server API
                    const res = await fetch('/agent/fetch-parcel-data', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ id: id })
                    });

                    if (res.ok) {
                        const json = await res.json();
                        // Update Data Model
                        const feature = parcelsData.features.find(f => f.properties.id === id);
                        if (feature && json.slope !== null) {
                            feature.properties.slope_mean = json.slope; // Update in memory

                            // Re-run Search (Silent update)
                            // We don't want to reset the view, just re-render list
                            findBestLands(false);
                        }
                    }
                } catch (e) {
                    console.error("Proactive Error", e);
                }

                // Small delay to be nice to server
                await new Promise(r => setTimeout(r, 500));
            }

            isAnalyzing = false;
            if (statusDiv) statusDiv.innerText = "";
        }

        function selectRec(id) {
            closeRecModal();
            const feature = parcelsData.features.find(f => f.properties.id === id);
            if (feature) {
                selectParcel(feature);
                // Zoom to feature
                const bbox = turf.bbox(feature);
                map.fitBounds(bbox, { padding: 100 });
            }
        }




    </script>

    <!-- MISSING TOUR LOGIC -->
    <script>
        // Tour & Welcome Logic
        document.addEventListener('DOMContentLoaded', () => {
            // Check Welcome on load
            setTimeout(() => {
                if (!localStorage.getItem('sawWelcome_v1')) {
                    document.getElementById('welcomeModal').classList.remove('hidden');
                }
            }, 1000);
        });

        function closeWelcomeModal() {
            document.getElementById('welcomeModal').classList.add('hidden');
            localStorage.setItem('sawWelcome_v1', 'true');
        }

        function startTour() {
            closeWelcomeModal();
            // Ensure Driver is loaded
            if (!window.driver) {
                console.error("Driver.js not loaded");
                alert("Tour library loading... please wait a moment and try again.");
                return;
            }
            const driver = window.driver.js.driver;

            const driverObj = driver({
                showProgress: true,
                steps: [
                    { element: '#sidebar', popover: { title: 'Control Panel', description: 'This is your command center. Use the Search filters and view parcel details here.' } },
                    { element: '#recModalBtn', popover: { title: 'Recommendation Engine', description: 'Click "Find Best Land" to let the AI find the best opportunities based on your criteria.' } },
                    { element: '#map', popover: { title: 'Smart Map', description: 'Click on any parcel on the map to see its details. Green borders indicate parcels that have already been analyzed.' } }
                ]
            });

            driverObj.drive();
        }
    </script>
</body>

</html>